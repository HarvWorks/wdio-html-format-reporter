/**
 * @type {accountsObject} = {  // Some of the keys maybe null
 *    "originatingUser": { @type {account} }
 *    "receivingUser1": { @type {account} }
 *    "receivingUser2": { @type {account} }
 *    "receivingUser3": { @type {account} }
 * }
 * 
 * @type {account} = {
 *    "email": @type {String},
 *    "password": @type {String},
 *    "accountType": @type {String},
 *    "securityAnswer": @type {String},
 *    "displayName": @type {String},
 *    "workLine": @type {String},
 *    "extension": @type {String},
 *    "cwl": @type {String},
 *    "username": @type {String}
 * }
 * 
 * @type {logtimeObject} = {
 *    logTime: @type {String},
 *    color: @type {String},
 *    suiteNumber: @type {int},
 *    browserName: @type {String}
 * }
 */
const crypto = require('crypto')
const events = require('events')
const Handlebars = require('handlebars')
const fs = require('fs-extra')
const _ = require('lodash');
const path = require('path')
const moment = require('moment')
const momentDurationFormatSetup = require("moment-duration-format");
momentDurationFormatSetup(moment);
const escapeStringRegexp = require('escape-string-regexp')
const Png = require("pngjs").PNG
const Jpeg = require("jpeg-js")

class HtmlReporter extends events.EventEmitter {
  constructor (baseReporter, config, options = {}) {
    super()
    this.baseReporter = baseReporter

    this.config = config
    this.errorCount = 0
    this.specs = {}
    this.results = {}
    this.baseReporter.stats.tempSuiteResults = {}
    this.baseReporter.stats.suiteResults = {}
    this.blankResults = {
      start: "",
      end: "",
      _duration: "",
      suiteResults: {
        passing: 0,
        pending: 0,
        failing: 0,
      },
      counts: {
        passes: 0,
        pending: 0,
        failures: 0
      },
      runners: {
        "0-0": {
          specs: {
            currentSpecs: {
              suites: {},
              logTimes: [],
              logTimeHeader: []
            }
          }
        }
      }
    }

    /**
     * This listens for `runner:start` which is generated by Webdriverio when starting up.
     * @param {object} runner this is the data passed by webdriverio when starting up.
     * This function also adds the blank results to the correct spec.
     */
    this.on('runner:start', function (runner) {
      this.specs[runner.cid] = runner.specs
      this.results[runner.cid] = {
        passing: 0,
        pending: 0,
        failing: 0
      }
      this.baseReporter.stats.tempSuiteResults = {
        passing: 0,
        pending: 0,
        failing: 0
      }
      this.baseReporter.stats.suiteResults = {
        passing: 0,
        pending: 0,
        failing: 0
      }
    })

    /**
     * Not currently used can be used to add functionality for when each suite/scenario starts
     * @param {object} runner this is the data passed by Webdriverio when a suite starts.
     */
    this.on('suite:start', function (suite) {})

    this.on('test:pending', function (test) {
      this.results[test.cid].pending++
      this.baseReporter.stats.tempSuiteResults.pending++
    })

    /**
     * This listens for when a test/step passes
     * @param {object} test this is the data passed by Webdriverio when a test/step passes.
     */
    this.on('test:pass', function (test) {
      this.results[test.cid].passing++
      this.baseReporter.stats.tempSuiteResults.passing++
    })

    /**
     * This listens for when a test/step passes
     * @param {object} test this is the data passed by Webdriverio when a test/step fails.
     */
    this.on('test:fail', function (test) {
        this.results[test.cid].failing++
        this.baseReporter.stats.tempSuiteResults.failing++
    })

    /**
     * This listens for a screen shot command generated by webdriverio
     * @param {object} test this is the data passed by Webdriverio when a screenshot is taken.
     */
    this.on('runner:screenshot', function (runner) {
      // if the filename isn't defined, do not add it to the report
      if (!runner.filename) {
        return
      }
      const spec = this.getSpec(runner.cid)
      const suiteKey = this.getSuiteKey(runner.cid)
      const currentTestKey = this.getCurrentTestKey(runner.cid)
      spec.suites[suiteKey].tests[currentTestKey].screenshots.push(runner.filename)
    })

    /**
     * This listens for `screenshot:fullpage`
     * @type {screenShot} This should contain the key `filename`
     * @param {screenShot} test this is the data passed by custom event
     */
    this.on('screenshot:fullpage', function (data) {
      // if the filename isn't defined, do not add it to the report
      if (!data.filename) {
        return
      }
      const spec = this.getSpec(data.cid)
      const suiteKey = this.getSuiteKey(data.cid)
      const currentTestKey = this.getCurrentTestKey(data.cid)
      spec.suites[suiteKey].tests[currentTestKey].screenshots.push(data.filename)
    })

    /**
     * This is emitted by webdriverio when each suite/scenario ends.
     * @param {object} runner this is the data passed by Webdriverio when a suite ends.
     * This function figures out if a suite is failing, passing or pending
     */
    this.on('suite:end', function (suite) {
      // Make copy of the the temp results
      const tempResults = { ...this.baseReporter.stats.tempSuiteResults }
      
      // Clear out the temp results at the end of the suite run
      this.baseReporter.stats.tempSuiteResults = {
        passing: 0,
        pending: 0,
        failing: 0
      }

      const spec = this.getSpec(suite.cid)
      const suiteKey = this.getSuiteKey(suite.cid)

      // Check which type of test was run, passing, pending, or failing and store it into the test suite and also increase the count. 
      // if there is no steps runs ran, it is a not a real test and ignore it
      if (tempResults.failing > 0) {
        spec.suites[suiteKey].status = "fail";
        return this.baseReporter.stats.suiteResults.failing ++
      } 
      if (tempResults.pending > 0) {
        spec.suites[suiteKey].status = "pending";
        return this.baseReporter.stats.suiteResults.pending ++
      }
      if (tempResults.passing > 0) {
        spec.suites[suiteKey].status = "pass";
        return this.baseReporter.stats.suiteResults.passing ++
      }
    })

    /**
     * Not currently used can be used to add functionality for when each runner from multi runner ends
     * @param {object} runner this is the data passed by Webdriverio when a runner ends.
     */
    this.on('runner:end', function (runner) {})

    /**
     * This is emitted by webdriverio when the entire process ends
     * @param {object} runner this is the data passed by Webdriverio when a process ends.
     * This merges any potential data that 
     */
    this.on('end', function () {
      const file = this.grabFile(this.getValidPath());
      let data = file.data;
      data.push(this.mergeData([this.baseReporter.stats]));
      fs.outputJsonSync(file.jsonfilePath, data)

      this.htmlOutput();
    })

    /**
     * This is a custom event that listens for `runner:logit`
     * @param {object} data This expects the key `output` as a string.
     * This generates a message in the HTML report right after a test finishes
     */
    this.on('runner:logit', function (data) {
      const spec = this.getSpec(data.cid)
      const suiteKey = this.getSuiteKey(data.cid)
      const currentTestKey = this.getCurrentTestKey(data.cid)

      if (spec.suites[suiteKey].tests[currentTestKey].logit == null) {
        spec.suites[suiteKey].tests[currentTestKey].logit = []
      }
      spec.suites[suiteKey].tests[currentTestKey].logit.push(data.output)
    })

    /**
     * This is a custom event that listens for `runner:logAccounts`
     * @param {object} data This expects the key `accounts` as @type {accountsObject}.
     * This adds the accounts object to each suite object
     */
    this.on('runner:logAccounts', function (data) {
      const spec = this.getSpec(data.cid)
      const suiteKey = this.getSuiteKey(data.cid)
      spec.suites[suiteKey].accounts = data.accounts;
    })

    /**
     * This is a custom event that listens for `runner:logSuiteNumber`
     * @param {accountsObject} data This expects the key `suiteNumber` as a number.
     * This adds the suite number to each suite object
     */
    this.on('runner:logSuiteNumber', function (data) {
      const spec = this.getSpec(data.cid)
      const suiteKey = this.getSuiteKey(data.cid)
      spec.suites[suiteKey].suiteNumber = data.suiteNumber;
    })

    /**
     * This is emitted by webdriverio when an error is generated
     * @param {object} data this is the data passed by Webdriverio when an error happens.
     * This generates an error
     */
    this.on('runner:logerror', function (data) {
      const suiteKey = this.getSuiteKey(data.cid)
      const spec = this.getSpec(data.cid)
      spec.suites[suiteKey].logerror = data.output
    })

    /**
     * This is a custom event that listens for `runner:logtime`
     * @param {object} data This expects the key `output` as  @type {logtimeObject}.
     * This adds how long it took the browsers to log into the application to the current spec
     */
    this.on('runner:logtime', function (data) {
      const spec = this.getSpec(data.cid)

      if (!spec.logTimes) {
        spec.logTimes = [];
      } 
      if (!spec.logTimeHeader) {
        spec.logTimeHeader = ["Suite"];
      } 

      const index = spec.logTimeHeader.findIndex(elem => elem === data.output.browserName);
      if (index < 0) {
        spec.logTimeHeader.push(data.output.browserName)
      }
      while(!spec.logTimes[data.output.suiteNumber - 1]) {
        spec.logTimes.push({});
      }

      spec.logTimes[data.output.suiteNumber - 1][data.output.browserName] = {
        logTime: data.output.logTime,
        color: data.output.color
      }
    })
  }

  /**
   * This generates the necessary data for the handlebars inside ./lib/wdio-html-reporter-template.hbs
   */
  htmlOutput() {
    let suiteCounter = 0;
    let source = fs.readFileSync(path.resolve(__dirname, '../lib/wdio-html-reporter-template.hbs'), 'utf8');

    /**
     * This converts the png files into base64 encoded image and is stored in the HTML file directly
     * @param {String} screenshotFile This is the file name
     * @param {String} screenshotPath This is the path where the file lives
     */
    Handlebars.registerHelper('imageAsBase64', function(screenshotFile, screenshotPath, options) {
      // occurs when there is an error file
      if (!fs.existsSync(screenshotFile)) {
        screenshotFile = `${screenshotPath}/${screenshotFile}`
      }
      let png = new Png.sync.read(fs.readFileSync(path.resolve(`${screenshotFile}`)))
      return `data:image/jpeg;base64,${Jpeg.encode(png, 50).data.toString('base64')}`
    })

    /**
     * This asks whether the suite/scenario is valid, ie: has tests in it.
     * @param {Object} suite complete suite object
     */
    Handlebars.registerHelper('isValidSuite', function(suite, options) {
      if (suite.title.length > 0 && Object.keys(suite.tests).length > 0 && suite.uid.match(new RegExp(escapeStringRegexp(suite.title)))) {
        return options.fn(this)
      }
      return options.inverse(this)
    })

    /**
     * This converts the state of a test/step into a css tag
     * @param {String} state should be `pass`, `fail`, or `pending`
     */
    Handlebars.registerHelper('testStateColour', function(state, options) {
      if (state === 'pass') {
        return 'test-pass'
      } else if (state === 'fail') {
        return 'test-fail'
      } else if (state === 'pending') {
        return 'test-pending'
      }
    })

    /**
     * This converts the state of a suite/scenario into a css tag
     * @param {String} state should be `pass`, `fail`, or `pending`
     */
    Handlebars.registerHelper('suiteStateColour', function(state, options) {
      if (state === 'pass') {
        return 'suite-pass'
      } else if (state === 'fail') {
        return 'suite-fail'
      } else if (state === 'pending') {
        return 'suite-pending'
      }
      return 'suite-unknown'
    })

    /**
     * This converts milliseconds to hours, minutes, seconds, and milliseconds format `hh:mm:ss.SS`
     * @param {int} duration should be in milliseconds
     */
    Handlebars.registerHelper('humanizeDuration', function(duration, options) {
      return moment.duration(duration, "milliseconds").format('hh:mm:ss.SS', {trim: false})
    })

    /**
     * This asks whether the suite/scenario is valid, ie: has tests in it.
     * @param {Object} testsHash the list of tests
     */
    Handlebars.registerHelper('ifSuiteHasTests', function(testsHash, options) {
      if (Object.keys(testsHash).length > 0) {
        return options.fn(this)
      }
      return options.inverse(this)
    })

    /**
     * This adds a suite number to the suite/scenario
     * @param {String} title
     */
    Handlebars.registerHelper('suiteAddCounter', function(title, options) {
      suiteCounter ++;
      return `${suiteCounter}: ${title}`;
    });

    /**
     * This check whether a suite/scenario has failed
     * @param {Object} tests the list of tests
     */
    Handlebars.registerHelper('ifSuiteHasFailure', function(tests, options) {
      let fail = _.values(tests).find((test) => {
        return test.state === 'fail'
      })
      if (fail != null) {
        return options.fn(this);
      }
      return options.inverse(this);
    });

    /**
     * This check whether a suite/scenario has failed
     * @param {Object} tests the list of tests
     */
    Handlebars.registerHelper('suiteStepFailure', function(tests, options) {
      let fail = _.values(tests).find((test) => {
        return test.state === 'fail'
      })
      return fail.title;
    });

    /**
     * This creates the table for the logtimes
     * @param {Object} spec the complete spec object
     */
    Handlebars.registerHelper('drawTableRows', function(spec, options) {
      const suiteTitles = _.values(spec.suites).filter(suite => Object.keys(suite.tests).length > 0 )
      .map(suite => {
        const length = 75;
        return suite.title.length <= length ? suite.title : `${suite.title.substr(0, length - 4)} ...`;
      });
      let result = ""

      spec.logTimes.forEach((logTimeRow, index) => {
        result = `${result}<tr>`;
        spec.logTimeHeader.forEach((browser, jndex) => {
          if (browser) {
            if (jndex === 0) {
              result = `${result}<td>${index + 1}: ${suiteTitles[index]}</td>`
            } else {
              let timeTook = '-';
              let attributes = `class="test-unknown"`
              if (logTimeRow && logTimeRow[browser] && logTimeRow[browser].logTime) {
                timeTook = logTimeRow[browser].logTime;
                attributes = `style="background-color:${logTimeRow[browser].color}"`;
              }
              result = `${result}<td ${attributes}>${timeTook}</td>`;
            }
          }
        })
        result = `${result}</tr>`;
      })
      return result;
    });

  
    const template = Handlebars.compile(source);
    const file = this.grabFile(this.getValidPath());
    const data = {stats: this.mergeData(file.data)};
    const result = template(data);
    const reportfile = `${this.getValidPath()}.html`;

    console.log(`View WDIO HTML Report at: ${reportfile}`);
    fs.outputFileSync(reportfile, result);
  }

  /**
   * This gets the current spec object
   * @param {object} cid The cid from a event
   */
  getSpec(cid) {
    const stats = this.baseReporter.stats
    const results = stats.runners[cid]
    const specHash = Object.keys(results.specs)[Object.keys(results.specs).length-1]
    return results.specs[specHash]
  }

  /**
   * This gets the latest suite/scenario
   * @param {object} cid The cid from a event
   */
  getSuiteKey(cid) {
    const spec = this.getSpec(cid);
    return Object.keys(spec.suites)[Object.keys(spec.suites).length-1]
  }

  /**
   * This gets the latest test/step
   * @param {object} cid The cid from a event
   */
  getCurrentTestKey(cid) {
    const spec = this.getSpec(cid);
    const suiteKey = this.getSuiteKey(cid);
    return Object.keys(spec.suites[suiteKey].tests)[Object.keys(spec.suites[suiteKey].tests).length-1]
  }

  /**
   * This grabs the data of the JSON file
   * @param {String} path path of a JSON file
   */
  grabFile(path) {
    let data = [];

    const jsonfilePath  = `${path}.json`;

    if (fs.pathExistsSync(jsonfilePath)) {
      data = fs.readJsonSync(jsonfilePath);
    }
    return {
      data,
      jsonfilePath
    };
  }

  /**
   * This gets the path and filename of the report depending on the whether the paths and filename were set in reporter options inside WDIO config file
   */
  getValidPath() {
    let result = `./wdio-report`
    if (
      this.config.reporterOptions && 
      this.config.reporterOptions.htmlFormat && 
      this.config.reporterOptions.htmlFormat.outputDir &&
      fs.pathExistsSync(this.config.reporterOptions.htmlFormat.outputDir)
    ) {
      const tempReportName = this.config.reporterOptions.htmlFormat.reportName
      let reportName = tempReportName ? tempReportName : `wdio-report`;
      result = `${this.config.reporterOptions.htmlFormat.outputDir}/${reportName}`
    }
    return result;
  }

  /**
   * This merges the test data in the array into a single object inside an array
   * @param {Array} data 
   */
  mergeData( data = [] ) {
    let results;
    data.forEach( stats => {
      if (!results) {
        results = JSON.parse(JSON.stringify(this.blankResults));
        results.start = stats.start;
      }
      // This makes sure that the very last run will overwrite the current time.
      results.end = stats.end;
      results._duration = stats._duration;

      results.suiteResults.passing += stats.suiteResults.passing;
      results.suiteResults.pending += stats.suiteResults.pending;
      results.suiteResults.failing += stats.suiteResults.failing;
      results.counts.passes += stats.counts.passes;
      results.counts.pending += stats.counts.pending;
      results.counts.failures += stats.counts.failures;

      _.values(stats.runners).forEach( runner => {
        _.values(runner.specs).forEach( spec => {
          _.values(spec.suites).forEach( suite => {
            const uuid = crypto.randomBytes(16).toString("hex");
            if (suite.tests && Object.keys(suite.tests).length !== 0) {
              results.runners["0-0"].specs.currentSpecs.suites[uuid] = suite;
            } else {
              delete results.runners["0-0"].specs.currentSpecs.suites[uuid];
            }
          })

          const currentLogTimes = results.runners["0-0"].specs.currentSpecs.logTimes;
          results.runners["0-0"].specs.currentSpecs.logTimes = currentLogTimes.concat(spec.logTimes);

          const currentLogTimeHeader = results.runners["0-0"].specs.currentSpecs.logTimeHeader
          results.runners["0-0"].specs.currentSpecs.logTimeHeader = this.mergeArrays(currentLogTimeHeader, spec.logTimeHeader);
        })
      })
    })
    return results;
  }

  /**
   * Helper function that merges 2 arrays for the test data
   * @param {Array} array1 
   * @param {Array} array2 
   */
  mergeArrays( array1, array2 ) {
    let results = array1.concat(array2);
    for (let i = 0; i < results.length; i ++) {
      for (let j  =i + 1; j < results.length; j ++) {
          if (results[i] === results[j])
              results.splice(j--, 1);
      }
    }
    return results;
  }
}
module.exports = HtmlReporter
